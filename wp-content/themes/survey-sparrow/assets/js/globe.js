let canvas,scene,renderer,data,globeElement;const container=document.querySelector(".js-globe"),elements={},groups={main:null,globe:null,globeDots:null,lines:null,lineDots:null},props={mapSize:{width:1024,height:512},globeRadius:200,dotsAmount:20,startingCountry:"india",colours:{globeDots:"rgb(255, 135, 60)",lines:new THREE.Color("#0079c9"),lineDots:new THREE.Color("#0079c9")},alphas:{globe:.4,lines:.5}},camera={object:null,controls:null,angles:{current:{azimuthal:null,polar:null},target:{azimuthal:null,polar:null}}},animations={finishedIntro:!1,dots:{current:0,total:170,points:[]},globe:{current:0,total:80},countries:{active:!1,animating:!1,current:0,total:120,selected:null,index:null,timeout:null,initialDuration:5e3,duration:2e3}};let isHidden=!1,setupReady=!1;const getData=async()=>{try{const e=await fetch("assets/js/globe-points-min.json");return data=await e.json(),window.onscroll=function(){window.scrollY>document.querySelector(".globe-container").offsetTop&&!setupReady&&(setupScene(),setupReady=!0)}}catch(e){return alert("Unable to get data")}},setupScene=()=>{canvas=container.querySelector(".js-canvas"),scene=new THREE.Scene,(renderer=new THREE.WebGLRenderer({canvas:canvas,antialias:!0,alpha:!0,shadowMapEnabled:!1})).setSize(canvas.clientWidth,canvas.clientHeight),renderer.setPixelRatio(1),renderer.setClearColor(0,0),groups.main=new THREE.Group,groups.main.name="Main",groups.lines=new THREE.Group,groups.lines.name="Lines",groups.main.add(groups.lines),groups.lineDots=new THREE.Group,groups.lineDots.name="Dots",groups.main.add(groups.lineDots),scene.add(groups.main),addCamera(),addControls(),addGlobe(),Object.keys(data.countries).length>0&&(addLines(),createListElements()),render(),animate();const e=()=>{const{innerWidth:e,innerHeight:t}=window;container.width=e,container.height=t,container.style.width=`${e}px`,container.style.height=`${t}px`,camera.object.aspect=container.offsetWidth/container.offsetHeight,camera.object.updateProjectionMatrix(),renderer.setSize(container.offsetWidth,container.offsetHeight)};window.addEventListener("resize",e),window.addEventListener("orientationchange",e),e()},addCamera=()=>{const{clientWidth:e,clientHeight:t}=canvas;camera.object=new THREE.PerspectiveCamera(60,e/t,1,1e4),camera.object.position.z=2.2*props.globeRadius},addControls=()=>{camera.controls=new OrbitControls(camera.object,canvas),camera.controls.enableKeys=!1,camera.controls.enablePan=!1,camera.controls.enableZoom=!1,camera.controls.enableDamping=!1,camera.controls.enableRotate=!1,camera.angles.current.azimuthal=-Math.PI,camera.angles.current.polar=0},render=()=>renderer.render(scene,camera.object),onFocusChange=e=>{const t="visible",n="hidden",o={focus:t,focusin:t,pageshow:t,blur:n,focusout:n,pagehide:n};e=e||window.event,isHidden=e.type in o};"hidden"in document?document.addEventListener("visibilitychange",onFocusChange):"mozHidden"in document?document.addEventListener("mozvisibilitychange",onFocusChange):"webkitHidden"in document?document.addEventListener("webkitvisibilitychange",onFocusChange):"msHidden"in document?document.addEventListener("msvisibilitychange",onFocusChange):"onfocusin"in document?document.onfocusin=document.onfocusout=onFocusChange:window.onpageshow=window.onpagehide=window.onfocus=window.onblur=onFocusChange;const animate=()=>{isHidden||requestAnimationFrame(animate),groups.globeDots&&introAnimate(),animations.finishedIntro&&animateDots(),animations.countries.animating&&animateCountryCycle(),positionElements(),camera.controls.update(),render()},addGlobe=()=>{const e=new THREE.TextureLoader;e.setCrossOrigin(!0);const t=props.globeRadius-.02*props.globeRadius,n=64,o=64,a=128,s=document.createElement("canvas");s.width=128,s.height=128;const i=s.getContext("2d");i.rect(0,0,128,128);const r=i.createLinearGradient(0,0,0,128);r.addColorStop(0," #4f4875"),r.addColorStop(.5,"#262238"),r.addColorStop(1,"#161421"),i.fillStyle=r,i.fill();const l=new THREE.Texture(s);l.needsUpdate=!0;const c=new THREE.SphereGeometry(t,64,64),d=new THREE.MeshBasicMaterial({map:l,transparent:!0,opacity:0});globeElement=new THREE.Mesh(c,d),groups.globe=new THREE.Group,groups.globe.name="Globe",groups.globe.add(globeElement),groups.main.add(groups.globe),addGlobeDots()},addGlobeDots=()=>{const e=new THREE.Geometry,t=16,n=8,o=document.createElement("canvas");o.width=16,o.height=16;const a=o.getContext("2d");a.beginPath(),a.arc(8,8,8,0,2*Math.PI),a.fillStyle=props.colours.globeDots,a.fill();const s=new THREE.Texture(o);s.needsUpdate=!0;const i=new THREE.PointsMaterial({map:s,size:props.globeRadius/120}),r=function({x:t,y:n}){const o=new THREE.Vector3(0,0,0);e.vertices.push(o);const a=returnSphericalCoordinates(t,n);animations.dots.points.push(new THREE.Vector3(a.x,a.y,a.z))};for(let e=0;e<data.points.length;e++)r(data.points[e]);for(let e in data.countries)r(data.countries[e]);groups.globeDots=new THREE.Points(e,i),groups.globe.add(groups.globeDots)},addLines=()=>{const e=new THREE.Geometry;for(const t in data.countries){const n=new THREE.Group;n.name=t;for(const o in data.countries){if(t===o)continue;const{start:a,mid:s,end:i}=returnCurveCoordinates(data.countries[t].x,data.countries[t].y,data.countries[o].x,data.countries[o].y),r=new THREE.QuadraticBezierCurve3(new THREE.Vector3(a.x,a.y,a.z),new THREE.Vector3(s.x,s.y,s.z),new THREE.Vector3(i.x,i.y,i.z));e.vertices=r.getPoints(200);const l=new MeshLine;l.setGeometry(e);const c=new MeshLineMaterial({color:props.colours.lines,transparent:!0,opacity:props.alphas.lines}),d=new THREE.Mesh(l.geometry,c);d._path=e.vertices,n.add(d)}n.visible=!1,groups.lines.add(n)}},addLineDots=()=>{const e=props.globeRadius/120,t=32,n=32,o=()=>new THREE.Mesh(new THREE.SphereGeometry(e,32,32),new THREE.MeshBasicMaterial({color:props.colours.lineDots}));for(let e=0;e<props.dotsAmount;e++){const e=o();e.visible=!1,e._pathIndex=null,e._path=null,groups.lineDots.add(e)}},assignDotsToRandomLine=e=>{let t=Math.random()*(animations.countries.selected.children.length-1);t=animations.countries.selected.children[t.toFixed(0)],e._path=t._path},reassignDotsToNewLines=()=>{for(let e=0;e<groups.lineDots.children.length;e++){const t=groups.lineDots.children[e];t._path&&t._pathIndex&&assignDotsToRandomLine(t)}},animateDots=()=>{for(let e=0;e<groups.lineDots.children.length;e++){const t=groups.lineDots.children[e];t._path?t._path&&t._pathIndex<t._path.length-1?(t.visible||(t.visible=!0),t.position.x=t._path[t._pathIndex].x,t.position.y=t._path[t._pathIndex].y,t.position.z=t._path[t._pathIndex].z,t._pathIndex++):(t.visible=!1,t._path=null):Math.random()>.99&&(assignDotsToRandomLine(t),t._pathIndex=0)}};let list;const createListElements=()=>{list=document.querySelector(".js-list");const e=(e,t)=>{const n=document.createElement("li"),{country:o}=data.countries[t];n.innerHTML=`<span class="text">${o}</span>`;const a={position:e,element:n};list.appendChild(n),elements[t]=a};let t=0;for(const n in data.countries){const o=groups.lines.getObjectByName(n),a=o.children[0]._path[0];if(e(a,n),n===props.startingCountry){animations.countries.index=t,animations.countries.selected=groups.lines.getObjectByName(n);let{visible:e,children:o}=animations.countries.selected;e=!0;for(let e=0;e<o.length;e++)o[e].material.uniforms.opacity.value=0;const{x:a,y:s}=data.countries[n],{azimuthal:i,polar:r}=returnCameraAngles(a,s);camera.angles.target.azimuthal=i,camera.angles.target.polar=r}else t++}},positionElements=()=>{const e=canvas.clientWidth/2,t=canvas.clientHeight/2;for(const n in elements){const{position:o,element:a}=elements[n],{x:s,y:i}=getProjectedPosition(e,t,o),r=a.style,l=`translate3D(${s}px, ${i}px, 0)`;r.webkitTransform=l,r.WebkitTransform=l,r.mozTransform=l,r.msTransform=l,r.oTransform=l,r.transform=l}},easeInOutCubic=e=>e<.5?4*e*e*e:(e-1)*(2*e-2)*(2*e-2)+1,easeOutCubic=e=>--e*e*e+1,easeInOutQuad=e=>e<.5?2*e*e:(4-2*e)*e-1,introAnimate=()=>{const{dots:e,globe:t,countries:n}=animations;if(e.current<=e.total){const t=groups.globeDots.geometry.vertices,n=t.length;for(let o=0;o<n;o++){let a=easeInOutCubic(e.current/e.total);if((a+=a*(o/n))>1&&(a=1),t[o].x=e.points[o].x*a,t[o].y=e.points[o].y*a,t[o].z=e.points[o].z*a,0===o){const{current:e,target:t}=camera.angles,n=(e.azimuthal-t.azimuthal)*a;camera.controls.setAzimuthalAngle(e.azimuthal-n);const o=(e.polar-t.polar)*a;camera.controls.setPolarAngle(e.polar-o)}}e.current++,groups.globeDots.geometry.verticesNeedUpdate=!0}if(e.current>=.65*e.total&&t.current<=t.total){const e=easeOutCubic(t.current/t.total);globeElement.material.opacity=props.alphas.globe*e;const o=n.selected.children;for(let t=0;t<o.length;t++)o[t].material.uniforms.opacity.value=props.alphas.lines*e;t.current++}if(e.current>=.7*e.total&&!n.active){list.classList.add("active");const e=Object.keys(data.countries)[n.index];changeCountry(e,!0),n.active=!0}n.active&&!animations.finishedIntro&&(animations.finishedIntro=!0,addLineDots())},changeCountry=(e,t)=>{animations.countries.selected&&(animations.countries.selected.visible=!1);for(const t in elements)t===e?elements[t].element.classList.add("active"):elements[t].element.classList.remove("active");if(animations.countries.selected=groups.lines.getObjectByName(e),animations.countries.selected.visible=!0,!t){camera.angles.current.azimuthal=camera.controls.getAzimuthalAngle(),camera.angles.current.polar=camera.controls.getPolarAngle();const{x:t,y:n}=data.countries[e],{azimuthal:o,polar:a}=returnCameraAngles(t,n);camera.angles.target.azimuthal=o,camera.angles.target.polar=a,animations.countries.animating=!0,reassignDotsToNewLines()}},animateCountryCycle=()=>{const{countries:e}=animations;if(e.current<e.total){const{current:t,target:n}=camera.angles,o=easeInOutQuad(e.current/e.total),a=(t.azimuthal-n.azimuthal)*o;camera.controls.setAzimuthalAngle(t.azimuthal-a);const s=(t.polar-n.polar)*o;camera.controls.setPolarAngle(t.polar-s),e.current++}else e.animating=!1,e.current=0},showNextCountry=()=>{let{countries:e}=animations;e.index++,e.index>=Object.keys(data.countries).length&&(e.index=0),changeCountry(Object.keys(data.countries)[e.index],!1)},returnSphericalCoordinates=(e,t)=>{e=(e-props.mapSize.width)/props.mapSize.width*-180,t=(t-props.mapSize.height)/props.mapSize.height*-90;const n=Math.cos(t/180*Math.PI)*props.globeRadius,o=Math.cos(e/180*Math.PI)*n,a=Math.sin(t/180*Math.PI)*props.globeRadius,s=Math.sin(e/180*Math.PI)*n;return{x:o,y:a,z:s}},returnCurveCoordinates=(e,t,n,o)=>{const a=returnSphericalCoordinates(e,t),s=returnSphericalCoordinates(n,o),i=(a.x+s.x)/2,r=(a.y+s.y)/2,l=(a.z+s.z)/2;let c=Math.pow(s.x-a.x,2);c+=Math.pow(s.y-a.y,2),c+=Math.pow(s.z-a.z,2),c=Math.sqrt(c);let d=Math.pow(i,2);d+=Math.pow(r,2),d+=Math.pow(l,2),d=Math.pow(c,2)/d;const u=i+(d*=.7)*i,p=r+d*r,m=l+d*l;return{start:{x:a.x,y:a.y,z:a.z},mid:{x:u,y:p,z:m},end:{x:s.x,y:s.y,z:s.z}}},getProjectedPosition=(e,t,n)=>{n=n.clone();const{x:o,y:a}=n.project(camera.object);return{x:o*e+e,y:-a*t+t}},returnCameraAngles=(e,t)=>{let n=(e-props.mapSize.width)/props.mapSize.width*Math.PI,o;return n+=Math.PI/2,{azimuthal:n+=.1,polar:t/(2*props.mapSize.height)*Math.PI}};window.WebGLRenderingContext?getData():alert("WebGL not supported, please use a browser that supports WebGL");